<template>
  <div class="editor-view">
    <menu class="top left">
      <button @click="clear">New</button>
      <button @click="save">Save</button>
      <button @click="reset">Reset</button>
    </menu>
    <nav class="top right">
      <a href="https://github.com/lanyizi/pathmusic-editor">Source Code</a>
    </nav>
    <template v-if="model">
      <select class="top center" v-model="displayMode">
        <option value="text">Text View</option>
        <option value="node-graph">Node Graphs</option>
      </select>
      <EventInspector class="left tall graph-view" :model="model" />
      <NodesTextView
        v-if="displayMode === 'text'"
        class="center text-view"
        :model="model"
      ></NodesTextView>
      <NodesGraphView v-else class="center graph-view" />
      <NodeInspector
        v-if="currentNode"
        class="right tall"
        :node="currentNode"
        :model="model"
      >
      </NodeInspector>
    </template>
    <div v-else-if="loading">Loading...</div>
    <div v-else class="center bottom">
      Please load tracks.txt, nodes.txt and events.txt generated by
      <a href="https://github.com/utunnels/ra3pathmusic">utunnels' tool</a>
      <br />
      Although not required (yet), but it's possible to use the ealayer3.exe by
      Ben Moench to convert sns files to mp3 and load them too.
      <br />
      See:
      <a href="https://bitbucket.org/Translu/ealayer3b/src/master/"
        >ealayer3b on BitBucket</a
      >
      and <a href="https://github.com/driftyz700/ealayer3-nfsw">Usage</a>
    </div>
    <BrowserFileProvider
      class="center"
      @file-loaded="fileAvailable = true"
    ></BrowserFileProvider>
  </div>
</template>
<script setup lang="ts">
import BrowserFileProvider from '@/components/BrowserFileProvider.vue';
import NodeInspector from '@/components/NodeInspector.vue';
import NodesTextView from '@/components/NodesTextView.vue';
import NodesGraphView from '@/components/NodesGraphView.vue';
import { useQueryNumberValue } from '@/composables/useQueryNumberValue';
import { provideFileStore } from '@/file-store';
import { createModel, type Model } from '@/model';
import {
  dumpEvents,
  dumpNodesAndRoutes,
  dumpTracks,
  parseEvents,
  parseNodesAndRoutes,
  parseTracks,
} from '@/parsers';
import { computed, watch } from 'vue';
import { ref } from 'vue';
import EventInspector from '@/components/EventInspector.vue';

const fileStore = provideFileStore();
const currentNodeId = useQueryNumberValue('node', -1);
const currentNode = computed(() => {
  console.log('currentNodeId.value', currentNodeId.value);
  return currentNodeId.value === -1
    ? null
    : model.value?.data.nodes[currentNodeId.value] ?? null;
});
const model = ref<Model | null>(null);
// for discarding changes and reset to original state
// back to when the files are loaded
const originalData = ref<[string, string, string] | null>(null);
const loading = ref(false);
const fileAvailable = ref(false);
const displayMode = ref<'text' | 'node-graph'>('text');

async function loadModel() {
  model.value = null;
  originalData.value = null;
  try {
    loading.value = true;
    const rawTracks = await fileStore.loadText('tracks.txt');
    const rawNodes = await fileStore.loadText('nodes.txt');
    const rawEvents = await fileStore.loadText('events.txt');
    const tracks = parseTracks(rawTracks);
    const { nodes, routes } = parseNodesAndRoutes(rawNodes);
    const { events, variables } = parseEvents(rawEvents, tracks, nodes);
    model.value = createModel(tracks, nodes, events, variables, routes);
    originalData.value = [rawTracks, rawNodes, rawEvents];
  } finally {
    loading.value = false;
  }
}
// load model when file is available
const stopWatching = watch(fileAvailable, () => {
  if (fileAvailable.value) {
    stopWatching();
    if (!model.value) {
      loadModel();
    }
  }
});

function clear() {
  fileStore.reset();
  fileAvailable.value = false;
  model.value = null;
}

async function save() {
  if (!model.value) {
    return;
  }
  const { tracks, nodes, events, variables, routers } = model.value.data;
  const rawEvents = dumpEvents(variables, events);
  const rawNodes = dumpNodesAndRoutes(nodes, routers);
  const rawTracks = dumpTracks(tracks);
  originalData.value = [rawTracks, rawNodes, rawEvents];
  await fileStore.saveText('events.txt', rawEvents);
  await fileStore.saveText('nodes.txt', rawNodes);
  await fileStore.saveText('tracks.txt', rawTracks);
}

function reset() {
  if (!originalData.value) {
    return;
  }
  const [rawTracks, rawNodes, rawEvents] = originalData.value;
  const tracks = parseTracks(rawTracks);
  const { nodes, routes } = parseNodesAndRoutes(rawNodes);
  const { events, variables } = parseEvents(rawEvents, tracks, nodes);
  model.value = createModel(tracks, nodes, events, variables, routes);
}
</script>
<style scoped>
.editor-view {
  display: grid;
  grid-template-rows: min-content minmax(0, 1fr) 0.4fr;
  grid-template-columns: 1fr 2fr 1fr;
}
.editor-view > menu {
  grid-column: 1 / 3;
  padding: 0;
  display: flex;
  justify-content: flex-start;
  gap: 0.5em;
  margin: 0.5em 0.5em 0 0.5em;
}
.editor-view > nav {
  padding: 0;
  display: flex;
  justify-content: flex-end;
  gap: 0.5em;
  margin: 0.5em 0.5em 0 0.5em;
}
.editor-view > * {
  margin: 0.5em;
}
.editor-view > .text-view {
  overflow-y: auto;
}
.editor-view > .graph-view {
  overflow: auto;
}
.left {
  grid-column: 1;
}
.center {
  grid-column: 2;
}
.right {
  grid-column: 3 / 4;
}
.top {
  grid-row: 1;
}
.bottom {
  grid-row: 3;
}
.tall {
  grid-row: 2 / 4;
}
</style>
