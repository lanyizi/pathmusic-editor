<template>
  <div>
    Please load tracks.txt, nodes.txt and events.txt generated by
    <a href="https://github.com/utunnels/ra3pathmusic">utunnels' tool</a>.
    <br />
    Although not required (yet), but it's possible to use the ealayer3.exe by
    Ben Moench to convert sns files to mp3 and load them too.
    <br />
    See:
    <a href="https://bitbucket.org/Translu/ealayer3b/src/master/"
      >ealayer3b on BitBucket</a
    >
    and <a href="https://github.com/driftyz700/ealayer3-nfsw">Usage</a>
    <br />
    <dl>
      <dt>Jonwil's research on PathMusic:</dt>
      <dd>
        <a
          href="https://ppmforums.com/post-602390/all-the-known-information-about-pathmusic-in-ra3/"
        >
          All the known information about PathMusic in RA3
        </a>
      </dd>
      <dt>SNR tool for RA3 PathMusic:</dt>
      <dd>
        <a href="https://github.com/utunnels/snrtool_for_ra3pathmusic">
          snrtool_for_ra3pathmusic
        </a>
      </dd>
    </dl>
  </div>
  <div
    class="drop-zone"
    ref="dropZone"
    @dragover="handleDragOver"
    @drop="handleFileDrop"
  >
    <div>
      <h2>Drop files here.</h2>
      Required files:
      <ul>
        <li v-for="file in requiredFileList" :key="file">
          {{ file }}
        </li>
      </ul>
    </div>
    <div>
      Available files:
      <ul>
        <li v-for="file in availableFilesList" :key="file.path">
          {{ file.path }}
        </li>
      </ul>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, ref, watchEffect } from 'vue';
import { useFileStore, type PendingReadTask } from '@/file-store';

const emit = defineEmits(['fileLoaded', 'wantFocus']);

const dropZone = ref<HTMLElement>(null as unknown as HTMLElement);
const {
  requestedTextFiles,
  requestedBinaryFiles,
  requestedResets,
  requestedTextSaves,
  requestedBinarySaves,
} = useFileStore();
const requiredFileList = computed(() =>
  (requestedTextFiles.value as PendingReadTask<any>[])
    .concat(requestedBinaryFiles.value)
    .map((file) => file.path)
);
interface AvailableFile {
  path: string;
  file: File;
}
const availableFilesList = ref<AvailableFile[]>([]);

watchEffect(() => {
  for (const resetRequest of requestedResets.value) {
    availableFilesList.value = [];
    resetRequest.resolve(Promise.resolve());
  }

  let anyUnfulfilled = false;
  const requestedTexts = [...requestedTextFiles.value];
  const requestedBinaries = [...requestedBinaryFiles.value];
  for (const requested of requestedTexts) {
    let unfulfilled = true;
    for (const available of availableFilesList.value) {
      if (requested.path == available.path) {
        unfulfilled = false;
        requested.resolve(available.file.text());
      }
    }
    if (unfulfilled) {
      anyUnfulfilled = true;
    }
  }
  for (const requested of requestedBinaries) {
    let unfulfilled = true;
    for (const available of availableFilesList.value) {
      if (requested.path == available.path) {
        unfulfilled = false;
        requested.resolve(available.file.arrayBuffer());
      }
    }
    if (unfulfilled) {
      anyUnfulfilled = true;
    }
  }

  if (anyUnfulfilled) {
    emit('wantFocus');
  }

  for (const requestedTextSave of requestedTextSaves.value) {
    download(requestedTextSave.data, requestedTextSave.path, 'text/plain');
    requestedTextSave.resolve(Promise.resolve());
  }
  for (const requestedBinarySave of requestedBinarySaves.value) {
    download(
      requestedBinarySave.data,
      requestedBinarySave.path,
      'application/octet-stream'
    );
    requestedBinarySave.resolve(Promise.resolve());
  }
});

function handleDragOver(event: DragEvent) {
  event.preventDefault();
  // Add CSS styles to indicate the drop zone is active
  dropZone.value.classList.add('drag-over');
}

function handleFileDrop(event: DragEvent) {
  event.preventDefault();
  // Remove CSS styles indicating active drop zone
  dropZone.value.classList.remove('drag-over');

  const files = event.dataTransfer?.files;
  if (files) {
    emit('fileLoaded');
    // Process the dropped files (e.g., upload, preview, etc.)
    handleFiles(files);
  }
}

function handleFiles(files: FileList) {
  // Process each file individually
  for (const file of files) {
    // Perform necessary operations (e.g., upload, read, etc.)
    availableFilesList.value = [
      ...availableFilesList.value,
      {
        path: file.name,
        file,
      },
    ];
  }
}

// https://stackoverflow.com/a/30832210/4399840
function download(data: BlobPart, filename: string, type: string) {
  const file = new Blob([data], { type });
  const navigator = window.navigator as Navigator & {
    msSaveOrOpenBlob?: (blob: Blob, filename: string) => void;
  };
  if (navigator.msSaveOrOpenBlob) {
    // IE10+
    navigator.msSaveOrOpenBlob(file, filename);
  } else {
    // Others
    const a = document.createElement('a');
    const url = URL.createObjectURL(file);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function () {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 0);
  }
}
</script>
<style scoped>
.drop-zone {
  margin-top: 1em;
  padding: 0.5em 1em;
  border: 4px dashed var(--color-border);
  display: grid;
  min-height: 30vh;
  grid-template-columns: 1fr 1fr;
  gap: 0.5em;
}

.drag-over {
  background-color: var(--color-background-soft);
}
</style>
